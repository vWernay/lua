-- Reference Decompiler: https://github.com/gottfriedleibniz/unluac/tree/luaglm
--  LConstantType requires slight alteration for this Lua.
--
-- Change Log (D/M/Y):
--  06/08/21: Complete refactor for LuaGLM
--  01/09/21: Update OP_TAILCALL to reflect "Undo simplification of tail calls"
--  21/10/21: Rebased.
Lua = {
    -- Enumerated types that must be shuffled
    Headers = setmetatable({
        Tests = "ltests_ops.h",
        LuaOp = "lua_op.h",
        TaggedMethods = { Opr = "ltm_tms.h", Names = "luaT_eventname.h", },
        UnaryOps = "lcode_unopr.h",
        BinaryOps = { Opr = "lcode_binopr.h", Priority = "lparser_priority.h", },
        Modes = "lopcodes_opmodes.h",
        Instructions = {
            Codes = "lopcodes_opcode.h",
            Names = "lopnames_opnames.h",
            VM = "lvm_vm.h",
        },
        Jumptable = "ljumptab_disptab.h",
    }, {
        __index = function(self, k)
            if Lua.KOperands.Base[k] ~= nil then
                return rawget(self, Lua.KOperands.Base[k])
            end
            return rawget(self, k)
        end
    }),

    -- "K" operand mapping.
    KOperands = {
        Base = { KInstructions = "Instructions", KModes = "Modes", },
        Lookup = { Instructions = "KInstructions", Modes = "KModes", },
    },
}

-- Deterministic ordering of header keys
Lua.Order = {
    "Tests",
    "LuaOp",
    "UnaryOps",
    "TaggedMethods",
    "BinaryOps",
    "Instructions",
    "Modes",
    "KModes",
    "KInstructions",
}

----------------------------------------
----------- Opcode Groupings -----------
----------------------------------------
Lua.Group = { }

-- Deterministic ordering of grouping keys
Lua.Group.Order = {
    "Instructions",
    "Comparison",
    "FastAccess",
    "Unary",
    "Binary",
    "Unsorted",
}

Lua.Group.Shuffle = {
    Instructions = true,
    Comparison = false, -- @TODO
    FastAccess = true,
    Unary = false, -- @TODO
    Binary = true,
    Unsorted = true,
}

-- @TODO: Decompose into multiple groups to allow sub-shuffling, e.g.,
-- {EQ, LT, LE} and {NE, GT, GE} must be congruent.
Lua.Group.Comparison = {
    BinaryOps = {
        Opr = {
            "OPR_EQ, /* comparison operator */",
            "OPR_LT, /* comparison operator */",
            "OPR_LE, /* comparison operator */",
            "OPR_NE, /* comparison operator */",
            "OPR_GT, /* comparison operator */",
            "OPR_GE, /* comparison operator */",
            "",
            "",
            "",
            "",
            "",
            "",
        },
        Priority = {
            "{3, 3}, /* == */",
            "{3, 3}, /* < */",
            "{3, 3}, /* <= */",
            "{3, 3}, /* ~= */",
            "{3, 3}, /* > */",
            "{3, 3}, /* >= */",
            "",
            "",
            "",
            "",
            "",
            "",
        },
    },
    Instructions = {
        Codes = {
            "OP_EQ,/*    A B k   if ((R[A] == R[B]) ~= k) then pc++      */",
            "OP_LT,/*    A B k   if ((R[A] <  R[B]) ~= k) then pc++      */",
            "OP_LE,/*    A B k   if ((R[A] <= R[B]) ~= k) then pc++      */",
            "",
            "",
            "",
            "OP_EQK,/*   A B k   if ((R[A] == K[B]) ~= k) then pc++      */",
            "OP_EQI,/*   A sB k  if ((R[A] == sB) ~= k) then pc++        */",
            "OP_LTI,/*   A sB k  if ((R[A] < sB) ~= k) then pc++         */",
            "OP_LEI,/*   A sB k  if ((R[A] <= sB) ~= k) then pc++        */",
            "OP_GTI,/*   A sB k  if ((R[A] > sB) ~= k) then pc++         */",
            "OP_GEI,/*   A sB k  if ((R[A] >= sB) ~= k) then pc++        */",
        },
        Names = {
            "\"EQ\",",
            "\"LT\",",
            "\"LE\",",
            "",
            "",
            "",
            "\"EQK\",",
            "\"EQI\",",
            "\"LTI\",",
            "\"LEI\",",
            "\"GTI\",",
            "\"GEI\",",
        },
        VM = {
            "vmcase(OP_EQ) {\n  int cond;\n  TValue *rb = vRB(i);\n  Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n  docondjump();\n  vmbreak;\n}",
            "vmcase(OP_LT) {\n  op_order(L, l_lti, LTnum, lessthanothers);\n  vmbreak;\n}",
            "vmcase(OP_LE) {\n  op_order(L, l_lei, LEnum, lessequalothers);\n  vmbreak;\n}",
            "",
            "",
            "",
            "vmcase(OP_EQK) {\n  TValue *rb = KB(i);\n  /* basic types do not use '__eq'; we can use raw equality */\n  int cond = luaV_rawequalobj(s2v(ra), rb);\n  docondjump();\n  vmbreak;\n}",
            "vmcase(OP_EQI) {\n  int cond;\n  int im = GETARG_sB(i);\n  if (ttisinteger(s2v(ra)))\n    cond = (ivalue(s2v(ra)) == im);\n  else if (ttisfloat(s2v(ra)))\n    cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n  else\n    cond = 0;  /* other types cannot be equal to a number */\n  docondjump();\n  vmbreak;\n}",
            "vmcase(OP_LTI) {\n  op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n  vmbreak;\n}",
            "vmcase(OP_LEI) {\n  op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n  vmbreak;\n}",
            "vmcase(OP_GTI) {\n  op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n  vmbreak;\n}",
            "vmcase(OP_GEI) {\n  op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n  vmbreak;\n}",
        },
    },
    Modes = {
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_EQ */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_LT */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_LE */",
        "",
        "",
        "",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_EQK */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_EQI */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_LTI */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_LEI */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_GTI */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_GEI */",
    },
}

Lua.Group.FastAccess = {
    TaggedMethods = {
        Opr = {
            "TM_INDEX,",
            "TM_NEWINDEX,",
            "TM_GC,",
            "TM_MODE,",
            "TM_LEN,",
            "TM_EQ,",
        },
        Names = {
            "\"__index\",",
            "\"__newindex\",",
            "\"__gc\",",
            "\"__mode\",",
            "\"__len\",",
            "\"__eq\",",
        },
    },
}

Lua.Group.Unary = {
    Tests = {
        "_",
        "!",
        "",
        "",
    },
    TaggedMethods = {
        Opr = {
            "TM_UNM,",
            "TM_BNOT,",
            "",
            "",
        },
        Names = {
            "\"__unm\",",
            "\"__bnot\",",
            "",
            "",
        },
    },
    LuaOp = {
        "LUA_OPUNM",
        "LUA_OPBNOT",
        "",
        "",
    },
    UnaryOps = {
        "OPR_MINUS,",
        "OPR_BNOT,",
        "OPR_NOT,",
        "OPR_LEN,",
    },
    Instructions = {
        Codes = {
            "OP_UNM,/*   A B R[A] := -R[B]                   */",
            "OP_BNOT,/*  A B R[A] := ~R[B]                   */",
            "OP_NOT,/*   A B R[A] := not R[B]                */",
            "OP_LEN,/*   A B R[A] := #R[B] (length operator) */",
        },
        Names = {
            "\"UNM\",",
            "\"BNOT\",",
            "\"NOT\",",
            "\"LEN\",",
        },
        VM = {
            "vmcase(OP_UNM) {\n  TValue *rb = vRB(i);\n  lua_Number nb;\n  if (ttisinteger(rb)) {\n    lua_Integer ib = ivalue(rb);\n    setivalue(s2v(ra), intop(-, 0, ib));\n  }\n  else if (tonumberns(rb, nb)) {\n    setfltvalue(s2v(ra), luai_numunm(L, nb));\n  }\n  else\n    Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n  vmbreak;\n}",
            "vmcase(OP_BNOT) {\n  TValue *rb = vRB(i);\n  lua_Integer ib;\n  if (tointegerns(rb, &ib)) {\n    setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n  }\n  else\n    Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n  vmbreak;\n}",
            "vmcase(OP_NOT) {\n  TValue *rb = vRB(i);\n  if (l_isfalse(rb))\n    setbtvalue(s2v(ra));\n  else\n    setbfvalue(s2v(ra));\n  vmbreak;\n}",
            "vmcase(OP_LEN) {\n  Protect(luaV_objlen(L, ra, vRB(i)));\n  vmbreak;\n}",
        },
    },
    Modes = {
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_UNM */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_BNOT */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_NOT */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_LEN */",
    },
}

Lua.Group.Binary = {
    Tests = {
        "+",
        "-",
        "*",
        "%",
        "^",
        "/",
        "\\\\",
        "&",
        "|",
        "~",
        "<",
        ">",
    },
    TaggedMethods = {
        Opr = {
            "TM_ADD,",
            "TM_SUB,",
            "TM_MUL,",
            "TM_MOD,",
            "TM_POW,",
            "TM_DIV,",
            "TM_IDIV,",
            "TM_BAND,",
            "TM_BOR,",
            "TM_BXOR,",
            "TM_SHL,",
            "TM_SHR,",
        },
        Names = {
            "\"__add\",",
            "\"__sub\",",
            "\"__mul\",",
            "\"__mod\",",
            "\"__pow\",",
            "\"__div\",",
            "\"__idiv\",",
            "\"__band\",",
            "\"__bor\",",
            "\"__bxor\",",
            "\"__shl\",",
            "\"__shr\",",
        },
    },
    LuaOp = {
        "LUA_OPADD",
        "LUA_OPSUB",
        "LUA_OPMUL",
        "LUA_OPMOD",
        "LUA_OPPOW",
        "LUA_OPDIV",
        "LUA_OPIDIV",
        "LUA_OPBAND",
        "LUA_OPBOR",
        "LUA_OPBXOR",
        "LUA_OPSHL",
        "LUA_OPSHR",
    },
    BinaryOps = {
        Opr = {
            "OPR_ADD, /* arithmetic operator */",
            "OPR_SUB, /* arithmetic operator */",
            "OPR_MUL, /* arithmetic operator */",
            "OPR_MOD, /* arithmetic operator */",
            "OPR_POW, /* arithmetic operator */",
            "OPR_DIV, /* arithmetic operator */",
            "OPR_IDIV, /* arithmetic operator */",
            "OPR_BAND, /* bitwise operator */",
            "OPR_BOR, /* bitwise operator */",
            "OPR_BXOR, /* bitwise operator */",
            "OPR_SHL, /* bitwise operator */",
            "OPR_SHR, /* bitwise operator */",
        },
        Priority = {
            "{10, 10}, /* '+' */",
            "{10, 10}, /* '-' */",
            "{11, 11}, /* '*' */",
            "{11, 11}, /* '%' */",
            "{14, 13}, /* '^' (right associative) */",
            "{11, 11}, /* '/' */",
            "{11, 11}, /* '//' */",
            "{6, 6}, /* '&' */",
            "{4, 4}, /* '|' */",
            "{5, 5}, /* '~' */",
            "{7, 7}, /* '<<' */",
            "{7, 7}, /* ''>>' */",
        },
    },
    Instructions = {
        Codes = {
            "OP_ADD,/*   A B C   R[A] := R[B] + R[C]             */",
            "OP_SUB,/*   A B C   R[A] := R[B] - R[C]             */",
            "OP_MUL,/*   A B C   R[A] := R[B] * R[C]             */",
            "OP_MOD,/*   A B C   R[A] := R[B] % R[C]             */",
            "OP_POW,/*   A B C   R[A] := R[B] ^ R[C]             */",
            "OP_DIV,/*   A B C   R[A] := R[B] / R[C]             */",
            "OP_IDIV,/*  A B C   R[A] := R[B] // R[C]            */",
            "OP_BAND,/*  A B C   R[A] := R[B] & R[C]             */",
            "OP_BOR,/*   A B C   R[A] := R[B] | R[C]             */",
            "OP_BXOR,/*  A B C   R[A] := R[B] ~ R[C]             */",
            "OP_SHL,/*   A B C   R[A] := R[B] << R[C]            */",
            "OP_SHR,/*   A B C   R[A] := R[B] >> R[C]            */",
        },
        Names = {
            "\"ADD\",",
            "\"SUB\",",
            "\"MUL\",",
            "\"MOD\",",
            "\"POW\",",
            "\"DIV\",",
            "\"IDIV\",",
            "\"BAND\",",
            "\"BOR\",",
            "\"BXOR\",",
            "\"SHL\",",
            "\"SHR\",",
        },
        VM = {
            "vmcase(OP_ADD) {\n  op_arith(L, l_addi, luai_numadd);\n  vmbreak;\n}",
            "vmcase(OP_SUB) {\n  op_arith(L, l_subi, luai_numsub);\n  vmbreak;\n}",
            "vmcase(OP_MUL) {\n  op_arith(L, l_muli, luai_nummul);\n  vmbreak;\n}",
            "vmcase(OP_MOD) {\n  op_arith(L, luaV_mod, luaV_modf);\n  vmbreak;\n}",
            "vmcase(OP_POW) {\n  op_arithf(L, luai_numpow);\n  vmbreak;\n}",
            "vmcase(OP_DIV) {  /* float division (always with floats) */\n  op_arithf(L, luai_numdiv);\n  vmbreak;\n}",
            "vmcase(OP_IDIV) {  /* floor division */\n  op_arith(L, luaV_idiv, luai_numidiv);\n  vmbreak;\n}",
            "vmcase(OP_BAND) {\n  op_bitwise(L, l_band);\n  vmbreak;\n}",
            "vmcase(OP_BOR) {\n  op_bitwise(L, l_bor);\n  vmbreak;\n}",
            "vmcase(OP_BXOR) {\n  op_bitwise(L, l_bxor);\n  vmbreak;\n}",
            "vmcase(OP_SHR) {\n  op_bitwise(L, luaV_shiftr);\n  vmbreak;\n}",
            "vmcase(OP_SHL) {\n  op_bitwise(L, luaV_shiftl);\n  vmbreak;\n}",
        },
    },
    Modes = {
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_ADD */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_SUB */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_MUL */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_MOD */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_POW */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_DIV */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_IDIV */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_BAND */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_BOR */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_BXOR */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_SHL */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_SHR */",
    },
    KInstructions = {
        Codes = {
            "OP_ADDK,/*  A B C   R[A] := R[B] + K[C]:number          */",
            "OP_SUBK,/*  A B C   R[A] := R[B] - K[C]:number          */",
            "OP_MULK,/*  A B C   R[A] := R[B] * K[C]:number          */",
            "OP_MODK,/*  A B C   R[A] := R[B] % K[C]:number          */",
            "OP_POWK,/*  A B C   R[A] := R[B] ^ K[C]:number          */",
            "OP_DIVK,/*  A B C   R[A] := R[B] / K[C]:number          */",
            "OP_IDIVK,/* A B C   R[A] := R[B] // K[C]:number         */",
            "OP_BANDK,/* A B C   R[A] := R[B] & K[C]:integer         */",
            "OP_BORK,/*  A B C   R[A] := R[B] | K[C]:integer         */",
            "OP_BXORK,/* A B C   R[A] := R[B] ~ K[C]:integer         */",
            "OP_SHRI,/*  A B sC  R[A] := R[B] >> sC                  */",
            "OP_SHLI,/*  A B sC  R[A] := sC << R[B]                  */",
        },
        Names = {
            "\"ADDK\",",
            "\"SUBK\",",
            "\"MULK\",",
            "\"MODK\",",
            "\"POWK\",",
            "\"DIVK\",",
            "\"IDIVK\",",
            "\"BANDK\",",
            "\"BORK\",",
            "\"BXORK\",",
            "\"SHRI\",",
            "\"SHLI\",",
        },
        VM = {
            "vmcase(OP_ADDK) {\n  op_arithK(L, l_addi, luai_numadd);\n  vmbreak;\n}",
            "vmcase(OP_SUBK) {\n  op_arithK(L, l_subi, luai_numsub);\n  vmbreak;\n}",
            "vmcase(OP_MULK) {\n  op_arithK(L, l_muli, luai_nummul);\n  vmbreak;\n}",
            "vmcase(OP_MODK) {\n  op_arithK(L, luaV_mod, luaV_modf);\n  vmbreak;\n}",
            "vmcase(OP_POWK) {\n  op_arithfK(L, luai_numpow);\n  vmbreak;\n}",
            "vmcase(OP_DIVK) {\n  op_arithfK(L, luai_numdiv);\n  vmbreak;\n}",
            "vmcase(OP_IDIVK) {\n  op_arithK(L, luaV_idiv, luai_numidiv);\n  vmbreak;\n}",
            "vmcase(OP_BANDK) {\n  op_bitwiseK(L, l_band);\n  vmbreak;\n}",
            "vmcase(OP_BORK) {\n  op_bitwiseK(L, l_bor);\n  vmbreak;\n}",
            "vmcase(OP_BXORK) {\n  op_bitwiseK(L, l_bxor);\n  vmbreak;\n}",
            "vmcase(OP_SHRI) {\n  TValue *rb = vRB(i);\n  int ic = GETARG_sC(i);\n  lua_Integer ib;\n  if (tointegerns(rb, &ib)) {\n    pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n  }\n  vmbreak;\n}",
            "vmcase(OP_SHLI) {\n  TValue *rb = vRB(i);\n  int ic = GETARG_sC(i);\n  lua_Integer ib;\n  if (tointegerns(rb, &ib)) {\n    pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n  }\n  vmbreak;\n}",
        },
    },
    KModes = {
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_ADDK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_SUBK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_MULK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_MODK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_POWK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_DIVK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_IDIVK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_BANDK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_BORK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_BXORK */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_SHRI */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_SHLI */",
    },
}

Lua.Group.Instructions = {
    Instructions = {
        Codes = {
            "OP_MOVE,/*  A B R[A] := R[B]                    */",
            "OP_LOADI,/* A sBx   R[A] := sBx                 */",
            "OP_LOADF,/* A sBx   R[A] := (lua_Number)sBx             */",
            "OP_LOADK,/* A Bx    R[A] := K[Bx]                   */",
            "OP_LOADKX,/*    A   R[A] := K[extra arg]                */",
            "OP_LOADFALSE,/* A   R[A] := false                   */",
            "OP_LFALSESKIP,/*A   R[A] := false; pc++ (*)         */",
            "OP_LOADTRUE,/*  A   R[A] := true                    */",
            "OP_LOADNIL,/*   A B R[A], R[A+1], ..., R[A+B] := nil        */",
            "OP_GETUPVAL,/*  A B R[A] := UpValue[B]              */",
            "OP_SETUPVAL,/*  A B UpValue[B] := R[A]              */",
            "OP_GETTABUP,/*  A B C   R[A] := UpValue[B][K[C]:string]         */",
            "OP_GETTABLE,/*  A B C   R[A] := R[B][R[C]]              */",
            "OP_GETI,/*  A B C   R[A] := R[B][C]                 */",
            "OP_GETFIELD,/*  A B C   R[A] := R[B][K[C]:string]           */",
            "OP_SETTABUP,/*  A B C   UpValue[A][K[B]:string] := RK(C)        */",
            "OP_SETTABLE,/*  A B C   R[A][R[B]] := RK(C)             */",
            "OP_SETI,/*  A B C   R[A][B] := RK(C)                */",
            "OP_SETFIELD,/*  A B C   R[A][K[B]:string] := RK(C)          */",
            "OP_NEWTABLE,/*  A B C k R[A] := {}                  */",
            "OP_SELF,/*  A B C   R[A+1] := R[B]; R[A] := R[B][RK(C):string]  */",
            "OP_ADDI,/*  A B sC  R[A] := R[B] + sC               */",
            "OP_MMBIN,/* A B C   call C metamethod over R[A] and R[B]    (*) */",
            "OP_MMBINI,/*    A sB C k    call C metamethod over R[A] and sB  */",
            "OP_MMBINK,/*    A B C k     call C metamethod over R[A] and K[B]    */",
            "OP_CONCAT,/*    A B R[A] := R[A].. ... ..R[A + B - 1]       */",
            "OP_CLOSE,/* A   close all upvalues >= R[A]          */",
            "OP_TBC,/*   A   mark variable A \"to be closed\"          */",
            "OP_JMP,/*   sJ  pc += sJ                    */",
            "OP_TEST,/*  A k if (not R[A] == k) then pc++            */",
            "OP_TESTSET,/*   A B k   if (not R[B] == k) then pc++ else R[A] := R[B] (*) */",
            "OP_CALL,/*  A B C   R[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */",
            "OP_TAILCALL,/*  A B C k return R[A](R[A+1], ... ,R[A+B-1])      */",
            "OP_RETURN,/*    A B C k return R[A], ... ,R[A+B-2]  (see note)  */",
            "OP_RETURN0,/*       return                      */",
            "OP_RETURN1,/*   A   return R[A]                 */",
            "OP_FORLOOP,/*   A Bx    update counters; if loop continues then pc-=Bx; */",
            "OP_FORPREP,/*   A Bx    <check values and prepare counters>; if not to run then pc+=Bx+1; */",
            "OP_TFORPREP,/*  A Bx    create upvalue for R[A + 3]; pc+=Bx     */",
            "OP_TFORCALL,/*  A C R[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);  */",
            "OP_TFORLOOP,/*  A Bx    if R[A+2] ~= nil then { R[A]=R[A+2]; pc -= Bx } */",
            "OP_SETLIST,/*   A B C k R[A][C+i] := R[A+i], 1 <= i <= B        */",
            -- @TODO: Defer
            "OP_CLOSURE,/*   A Bx    R[A] := closure(KPROTO[Bx])         */",
            "OP_VARARG,/*    A C R[A], R[A+1], ..., R[A+C-2] = vararg        */",
            "OP_VARARGPREP,/*A   (adjust vararg parameters)          */",
            "OP_EXTRAARG,/*   Ax  extra (larger) argument for previous opcode */",
        },
        Names = {
            "\"MOVE\",",
            "\"LOADI\",",
            "\"LOADF\",",
            "\"LOADK\",",
            "\"LOADKX\",",
            "\"LOADFALSE\",",
            "\"LFALSESKIP\",",
            "\"LOADTRUE\",",
            "\"LOADNIL\",",
            "\"GETUPVAL\",",
            "\"SETUPVAL\",",
            "\"GETTABUP\",",
            "\"GETTABLE\",",
            "\"GETI\",",
            "\"GETFIELD\",",
            "\"SETTABUP\",",
            "\"SETTABLE\",",
            "\"SETI\",",
            "\"SETFIELD\",",
            "\"NEWTABLE\",",
            "\"SELF\",",
            "\"ADDI\",",
            "\"MMBIN\",",
            "\"MMBINI\",",
            "\"MMBINK\",",
            "\"CONCAT\",",
            "\"CLOSE\",",
            "\"TBC\",",
            "\"JMP\",",
            "\"TEST\",",
            "\"TESTSET\",",
            "\"CALL\",",
            "\"TAILCALL\",",
            "\"RETURN\",",
            "\"RETURN0\",",
            "\"RETURN1\",",
            "\"FORLOOP\",",
            "\"FORPREP\",",
            "\"TFORPREP\",",
            "\"TFORCALL\",",
            "\"TFORLOOP\",",
            "\"SETLIST\",",
            -- @TODO: Defer
            "\"CLOSURE\",",
            "\"VARARG\",",
            "\"VARARGPREP\",",
            "\"EXTRAARG\",",
        },
        VM = {
            "vmcase(OP_MOVE) {\n  setobjs2s(L, ra, RB(i));\n  vmbreak;\n}",
            "vmcase(OP_LOADI) {\n  lua_Integer b = GETARG_sBx(i);\n  setivalue(s2v(ra), b);\n  vmbreak;\n}",
            "vmcase(OP_LOADF) {\n  int b = GETARG_sBx(i);\n  setfltvalue(s2v(ra), cast_num(b));\n  vmbreak;\n}",
            "vmcase(OP_LOADK) {\n  TValue *rb = k + GETARG_Bx(i);\n  setobj2s(L, ra, rb);\n  vmbreak;\n}",
            "vmcase(OP_LOADKX) {\n  TValue *rb;\n  rb = k + GETARG_Ax(*pc); pc++;\n  setobj2s(L, ra, rb);\n  vmbreak;\n}",
            "vmcase(OP_LOADFALSE) {\n  setbfvalue(s2v(ra));\n  vmbreak;\n}",
            "vmcase(OP_LFALSESKIP) {\n  setbfvalue(s2v(ra));\n  pc++;  /* skip next instruction */\n  vmbreak;\n}",
            "vmcase(OP_LOADTRUE) {\n  setbtvalue(s2v(ra));\n  vmbreak;\n}",
            "vmcase(OP_LOADNIL) {\n  int b = GETARG_B(i);\n  do {\n    setnilvalue(s2v(ra++));\n  } while (b--);\n  vmbreak;\n}",
            "vmcase(OP_GETUPVAL) {\n  int b = GETARG_B(i);\n  setobj2s(L, ra, cl->upvals[b]->v);\n  vmbreak;\n}",
            "vmcase(OP_SETUPVAL) {\n  UpVal *uv = cl->upvals[GETARG_B(i)];\n  setobj(L, uv->v, s2v(ra));\n  luaC_barrier(L, uv, s2v(ra));\n  vmbreak;\n}",
            "vmcase(OP_GETTABUP) {\n  TValue *upval = cl->upvals[GETARG_B(i)]->v;\n  TValue *rc = KC(i);\n  TString *key = tsvalue(rc);  /* key must be a string */\n  if (ttisvector(upval)) {\n    if (l_unlikely(!glmVec_fastgets(upval, key, ra)))\n      Protect(glmVec_get(L, upval, rc, ra));\n  }\n  else {\n    const TValue *slot;\n    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n      setobj2s(L, ra, slot);\n    }\n    else\n      Protect(luaV_finishget(L, upval, rc, ra, slot));\n  }\n  vmbreak;\n}",
            "vmcase(OP_GETTABLE) {\n  TValue *rb = vRB(i);\n  TValue *rc = vRC(i);\n  if (ttisvector(rb)) {  /* fast track for integers / character indexing? */\n    if (ttisinteger(rc) && glmVec_fastgeti(rb, ivalue(rc), ra)) { /* nothing */ }\n    else if (ttisstring(rc) && glmVec_fastgets(rb, tsvalue(rc), ra)) { /* nothing */ }\n    else {\n      Protect(glmVec_get(L, rb, rc, ra));\n    }\n  }\n  else if (ttismatrix(rb)) {  /* fast track for integers? */\n    if (ttisinteger(rc) && glmMat_fastgeti(rb, ivalue(rc), ra)) { /* nothing */ }\n    else {\n      Protect(glmMat_get(L, rb, rc, ra));\n    }\n  }\n  else {\n    const TValue *slot;\n    lua_Unsigned n;\n    if (ttisinteger(rc)  /* fast track for integers? */\n        ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n        : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n      setobj2s(L, ra, slot);\n    }\n    else\n      Protect(luaV_finishget(L, rb, rc, ra, slot));\n  }\n  vmbreak;\n}",
            "vmcase(OP_GETI) {\n  TValue *rb = vRB(i);\n  int c = GETARG_C(i);\n  if (ttisvector(rb)) {  /* fast track for integers? */\n    if (l_unlikely(!glmVec_fastgeti(rb, c, ra)))\n      Protect(glmVec_geti(L, rb, c, ra));\n  }\n  else if (ttismatrix(rb)) {\n    if (l_unlikely(!glmMat_fastgeti(rb, c, ra)))\n      Protect(glmMat_geti(L, rb, c, ra));\n  }\n  else {\n    const TValue *slot;\n    if (luaV_fastgeti(L, rb, c, slot)) {\n      setobj2s(L, ra, slot);\n    }\n    else {\n      TValue key;\n      setivalue(&key, c);\n      Protect(luaV_finishget(L, rb, &key, ra, slot));\n    }\n  }\n  vmbreak;\n}",
            "vmcase(OP_GETFIELD) {\n  TValue *rb = vRB(i);\n  TValue *rc = KC(i);\n  TString *key = tsvalue(rc);  /* key must be a string */\n  if (ttisvector(rb)) {\n    if (l_unlikely(!glmVec_fastgets(rb, key, ra)))\n      Protect(glmVec_get(L, rb, rc, ra));\n  }\n  else {\n    const TValue *slot;\n    if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n      setobj2s(L, ra, slot);\n    }\n    else\n      Protect(luaV_finishget(L, rb, rc, ra, slot));\n  }\n  vmbreak;\n}",
            "vmcase(OP_SETTABUP) {\n  TValue *upval = cl->upvals[GETARG_A(i)]->v;\n  TValue *rb = KB(i);\n  TValue *rc = RKC(i);\n  if (ttismatrix(upval))\n    Protect(glmMat_set(L, upval, rb, rc));\n  else {\n    const TValue *slot;\n    TString *key = tsvalue(rb);  /* key must be a string */\n    if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n      luaV_finishfastset(L, upval, slot, rc);\n    }\n    else\n      Protect(luaV_finishset(L, upval, rb, rc, slot));\n  }\n  vmbreak;\n}",
            "vmcase(OP_SETTABLE) {\n  TValue *rb = vRB(i);  /* key (table is in 'ra') */\n  TValue *rc = RKC(i);  /* value */\n  if (ttismatrix(s2v(ra)))\n    Protect(glmMat_set(L, s2v(ra), rb, rc));\n  else {\n    const TValue *slot;\n    lua_Unsigned n;\n    if (ttisinteger(rb)  /* fast track for integers? */\n        ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n        : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n      luaV_finishfastset(L, s2v(ra), slot, rc);\n    }\n    else\n      Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n  }\n  vmbreak;\n}",
            "vmcase(OP_SETI) {\n  int c = GETARG_B(i);\n  TValue *rc = RKC(i);\n  if (ttismatrix(s2v(ra)))\n    Protect(glmMat_seti(L, s2v(ra), c, rc));\n  else {\n    const TValue *slot;\n    if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n      luaV_finishfastset(L, s2v(ra), slot, rc);\n    }\n    else {\n      TValue key;\n      setivalue(&key, c);\n      Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n    }\n  }\n  vmbreak;\n}",
            "vmcase(OP_SETFIELD) {\n  const TValue *slot;\n  TValue *rb = KB(i);\n  TValue *rc = RKC(i);\n  TString *key = tsvalue(rb);  /* key must be a string */\n  if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n    luaV_finishfastset(L, s2v(ra), slot, rc);\n  }\n  else\n    Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n  vmbreak;\n}",
            "vmcase(OP_NEWTABLE) {\n  int b = GETARG_B(i);  /* log2(hash size) + 1 */\n  int c = GETARG_C(i);  /* array size */\n  Table *t;\n  if (b > 0)\n    b = 1 << (b - 1);  /* size is 2^(b - 1) */\n  lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n  if (TESTARG_k(i))  /* non-zero extra argument? */\n    c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n  pc++;  /* skip extra argument */\n  L->top = ra + 1;  /* correct top in case of emergency GC */\n  t = luaH_new(L);  /* memory allocation */\n  sethvalue2s(L, ra, t);\n  if (b != 0 || c != 0)\n    luaH_resize(L, t, c, b);  /* idem */\n  checkGC(L, ra + 1);\n  vmbreak;\n}",
            "vmcase(OP_SELF) {\n  TValue *rb = vRB(i);\n  TValue *rc = RKC(i);\n  TString *key = tsvalue(rc);  /* key must be a string */\n  setobj2s(L, ra + 1, rb);\n  if (ttisvector(rb)) {  /* key must be a string */\n    if (l_unlikely(!glmVec_fastgets(rb, key, ra)))\n      Protect(glmVec_get(L, rb, rc, ra));\n  }\n  else {\n    const TValue *slot;\n    if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n      setobj2s(L, ra, slot);\n    }\n    else\n      Protect(luaV_finishget(L, rb, rc, ra, slot));\n  }\n  vmbreak;\n}",
            "vmcase(OP_ADDI) {\n  op_arithI(L, l_addi, luai_numadd);\n  vmbreak;\n}",
            "vmcase(OP_MMBIN) {\n  Instruction pi = *(pc - 2);  /* original arith. expression */\n  TValue *rb = vRB(i);\n  TMS tm = (TMS)GETARG_C(i);\n  StkId result = RA(pi);\n  lua_assert(luaop_fold(GET_OPCODE(pi)));\n  Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n  vmbreak;\n}",
            "vmcase(OP_MMBINI) {\n  Instruction pi = *(pc - 2);  /* original arith. expression */\n  int imm = GETARG_sB(i);\n  TMS tm = (TMS)GETARG_C(i);\n  int flip = GETARG_k(i);\n  StkId result = RA(pi);\n  Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n  vmbreak;\n}",
            "vmcase(OP_MMBINK) {\n  Instruction pi = *(pc - 2);  /* original arith. expression */\n  TValue *imm = KB(i);\n  TMS tm = (TMS)GETARG_C(i);\n  int flip = GETARG_k(i);\n  StkId result = RA(pi);\n  Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n  vmbreak;\n}",
            "vmcase(OP_CONCAT) {\n  int n = GETARG_B(i);  /* number of elements to concatenate */\n  L->top = ra + n;  /* mark the end of concat operands */\n  ProtectNT(luaV_concat(L, n));\n  checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n  vmbreak;\n}",
            "vmcase(OP_CLOSE) {\n  Protect(luaF_close(L, ra, LUA_OK, 1));\n  vmbreak;\n}",
            "vmcase(OP_TBC) {\n  /* create new to-be-closed upvalue */\n#if defined(GRIT_POWER_DEFER)\n  halfProtect(luaF_newtbcupval(L, ra, 0));\n#else\n  halfProtect(luaF_newtbcupval(L, ra));\n#endif\n  vmbreak;\n}",
            "vmcase(OP_JMP) {\n  dojump(ci, i, 0);\n  vmbreak;\n}",
            "vmcase(OP_TEST) {\n  int cond = !l_isfalse(s2v(ra));\n  docondjump();\n  vmbreak;\n}",
            "vmcase(OP_TESTSET) {\n  TValue *rb = vRB(i);\n  if (l_isfalse(rb) == GETARG_k(i))\n    pc++;\n  else {\n    setobj2s(L, ra, rb);\n    donextjump(ci);\n  }\n  vmbreak;\n}",
            "vmcase(OP_CALL) {\n  CallInfo *newci;\n  int b = GETARG_B(i);\n  int nresults = GETARG_C(i) - 1;\n  if (b != 0)  /* fixed number of arguments? */\n    L->top = ra + b;  /* top signals number of arguments */\n  /* else previous instruction set top */\n  savepc(L);  /* in case of errors */\n  if ((newci = luaD_precall(L, ra, nresults)) == NULL)\n    updatetrap(ci);  /* C call; nothing else to be done */\n  else {  /* Lua call: run function in this same C frame */\n    ci = newci;\n    goto startfunc;\n  }\n  vmbreak;\n}",
            "vmcase(OP_TAILCALL) {\n  int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n  int nparams1 = GETARG_C(i);\n  /* delta is virtual 'func' - real 'func' (vararg functions) */\n  int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n  if (b != 0)\n    L->top = ra + b;\n  else  /* previous instruction set top */\n    b = cast_int(L->top - ra);\n  savepc(ci);  /* several calls here can raise errors */\n  if (TESTARG_k(i)) {\n    luaF_closeupval(L, base);  /* close upvalues from current call */\n    lua_assert(L->tbclist < base);  /* no pending tbc variables */\n    lua_assert(base == ci->func + 1);\n  }\n  while (!ttisfunction(s2v(ra))) {  /* not a function? */\n    ra = luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */\n    b++;  /* there is now one extra argument */\n  }\n  if (!ttisLclosure(s2v(ra))) {  /* C function? */\n    luaD_precall(L, ra, LUA_MULTRET);  /* call it */\n    updatetrap(ci);\n    updatestack(ci);  /* stack may have been relocated */\n    ci->func -= delta;  /* restore 'func' (if vararg) */\n    luaD_poscall(L, ci, cast_int(L->top - ra));  /* finish caller */\n    updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n    goto ret;  /* caller returns after the tail call */\n  }\n  else {  /* Lua function */\n    ci->func -= delta;  /* restore 'func' (if vararg) */\n    luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */\n    goto startfunc;  /* execute the callee */\n  }\n}",
            "vmcase(OP_RETURN) {\n  int n = GETARG_B(i) - 1;  /* number of results */\n  int nparams1 = GETARG_C(i);\n  if (n < 0)  /* not fixed? */\n    n = cast_int(L->top - ra);  /* get what is available */\n  savepc(ci);\n  if (TESTARG_k(i)) {  /* may there be open upvalues? */\n    ci->u2.nres = n;  /* save number of returns */\n    if (L->top < ci->top)\n      L->top = ci->top;\n    luaF_close(L, base, CLOSEKTOP, 1);\n    updatetrap(ci);\n    updatestack(ci);\n  }\n  if (nparams1)  /* vararg function? */\n    ci->func -= ci->u.l.nextraargs + nparams1;\n  L->top = ra + n;  /* set call for 'luaD_poscall' */\n  luaD_poscall(L, ci, n);\n  updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n  goto ret;\n}",
            "vmcase(OP_RETURN0) {\n  if (l_unlikely(L->hookmask)) {\n    L->top = ra;\n    savepc(ci);\n    luaD_poscall(L, ci, 0);  /* no hurry... */\n    trap = 1;\n  }\n  else {  /* do the 'poscall' here */\n    int nres;\n    L->ci = ci->previous;  /* back to caller */\n    L->top = base - 1;\n    for (nres = ci->nresults; l_unlikely(nres > 0); nres--)\n      setnilvalue(s2v(L->top++));  /* all results are nil */\n  }\n  goto ret;\n}",
            "vmcase(OP_RETURN1) {\n  if (l_unlikely(L->hookmask)) {\n    L->top = ra + 1;\n    savepc(ci);\n    luaD_poscall(L, ci, 1);  /* no hurry... */\n    trap = 1;\n  }\n  else {  /* do the 'poscall' here */\n    int nres = ci->nresults;\n    L->ci = ci->previous;  /* back to caller */\n    if (nres == 0)\n      L->top = base - 1;  /* asked for no results */\n    else {\n      setobjs2s(L, base - 1, ra);  /* at least this result */\n      L->top = base;\n      for (; l_unlikely(nres > 1); nres--)\n        setnilvalue(s2v(L->top++));  /* complete missing results */\n    }\n  }\n ret:  /* return from a Lua function */\n  if (ci->callstatus & CIST_FRESH)\n    return;  /* end this frame */\n  else {\n    ci = ci->previous;\n    goto returning;  /* continue running caller in this frame */\n  }\n}",
            "vmcase(OP_FORLOOP) {\n  if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n    lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n    if (count > 0) {  /* still more iterations? */\n      lua_Integer step = ivalue(s2v(ra + 2));\n      lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n      chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n      idx = intop(+, idx, step);  /* add step to index */\n      chgivalue(s2v(ra), idx);  /* update internal index */\n      setivalue(s2v(ra + 3), idx);  /* and control variable */\n      pc -= GETARG_Bx(i);  /* jump back */\n    }\n  }\n  else if (floatforloop(ra))  /* float loop */\n    pc -= GETARG_Bx(i);  /* jump back */\n  updatetrap(ci);  /* allows a signal to break the loop */\n  vmbreak;\n}",
            "vmcase(OP_FORPREP) {\n  savestate(L, ci);  /* in case of errors */\n  if (forprep(L, ra))\n    pc += GETARG_Bx(i) + 1;  /* skip the loop */\n  vmbreak;\n}",
            "vmcase(OP_TFORPREP) {\n  /* create to-be-closed upvalue (if needed) */\n#if defined(GRIT_POWER_DEFER)\n  halfProtect(luaF_newtbcupval(L, ra + 3, 0));\n#else\n  halfProtect(luaF_newtbcupval(L, ra + 3));\n#endif\n  pc += GETARG_Bx(i);\n  i = *(pc++);  /* go to next instruction */\n  lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n  goto l_tforcall;\n}",
            "vmcase(OP_TFORCALL) {\n l_tforcall:\n  /* 'ra' has the iterator function, 'ra + 1' has the state,\n     'ra + 2' has the control variable, and 'ra + 3' has the\n     to-be-closed variable. The call will use the stack after\n     these values (starting at 'ra + 4')\n  */\n  /* push function, state, and control variable */\n  memcpy(ra + 4, ra, 3 * sizeof(*ra));\n  L->top = ra + 4 + 3;\n  ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n  updatestack(ci);  /* stack may have changed */\n  i = *(pc++);  /* go to next instruction */\n  lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n  goto l_tforloop;\n}",
            "vmcase(OP_TFORLOOP) {\n  l_tforloop:\n  if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n    setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n    pc -= GETARG_Bx(i);  /* jump back */\n  }\n  vmbreak;\n}",
            "vmcase(OP_SETLIST) {\n  int n = GETARG_B(i);\n  unsigned int last = GETARG_C(i);\n  Table *h = hvalue(s2v(ra));\n  if (n == 0)\n    n = cast_int(L->top - ra) - 1;  /* get up to the top */\n  else\n    L->top = ci->top;  /* correct top in case of emergency GC */\n  last += n;\n  if (TESTARG_k(i)) {\n    last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n    pc++;\n  }\n  if (last > luaH_realasize(h))  /* needs more space? */\n    luaH_resizearray(L, h, last);  /* preallocate it at once */\n  for (; n > 0; n--) {\n    TValue *val = s2v(ra + n);\n    setobj2t(L, &h->array[last - 1], val);\n    last--;\n    luaC_barrierback(L, obj2gco(h), val);\n  }\n  vmbreak;\n}",
            -- @TODO: Defer "vmcase(OP_DEFER) {\n  halfProtect(luaF_newtbcupval(L, ra, 1));\n  vmbreak;\n}\n#endif",
            "vmcase(OP_CLOSURE) {\n  Proto *p = cl->p->p[GETARG_Bx(i)];\n  halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n  checkGC(L, ra + 1);\n  vmbreak;\n}\n",
            "vmcase(OP_VARARG) {\n  int n = GETARG_C(i) - 1;  /* required results */\n  Protect(luaT_getvarargs(L, ci, ra, n));\n  vmbreak;\n}",
            "vmcase(OP_VARARGPREP) {\n  ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n  if (l_unlikely(trap)) {  /* previous \"Protect\" updated trap */\n    luaD_hookcall(L, ci);\n    L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n  }\n  updatebase(ci);  /* function has new base after adjustment */\n  vmbreak;\n}",
            "vmcase(OP_EXTRAARG) {\n  lua_assert(0);\n  vmbreak;\n}",
        },
    },
    Modes = {
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_MOVE */",
        "opmode(0, 0, 0, 0, 1, iAsBx),      /* OP_LOADI */",
        "opmode(0, 0, 0, 0, 1, iAsBx),      /* OP_LOADF */",
        "opmode(0, 0, 0, 0, 1, iABx),       /* OP_LOADK */",
        "opmode(0, 0, 0, 0, 1, iABx),       /* OP_LOADKX */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_LOADFALSE */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_LFALSESKIP */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_LOADTRUE */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_LOADNIL */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_GETUPVAL */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_SETUPVAL */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_GETTABUP */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_GETTABLE */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_GETI */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_GETFIELD */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_SETTABUP */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_SETTABLE */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_SETI */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_SETFIELD */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_NEWTABLE */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_SELF */",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_ADDI */",
        "opmode(1, 0, 0, 0, 0, iABC),       /* OP_MMBIN */",
        "opmode(1, 0, 0, 0, 0, iABC),       /* OP_MMBINI*/",
        "opmode(1, 0, 0, 0, 0, iABC),       /* OP_MMBINK*/",
        "opmode(0, 0, 0, 0, 1, iABC),       /* OP_CONCAT */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_CLOSE */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_TBC */",
        "opmode(0, 0, 0, 0, 0, isJ),        /* OP_JMP */",
        "opmode(0, 0, 0, 1, 0, iABC),       /* OP_TEST */",
        "opmode(0, 0, 0, 1, 1, iABC),       /* OP_TESTSET */",
        "opmode(0, 1, 1, 0, 1, iABC),       /* OP_CALL */",
        "opmode(0, 1, 1, 0, 1, iABC),       /* OP_TAILCALL */",
        "opmode(0, 0, 1, 0, 0, iABC),       /* OP_RETURN */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_RETURN0 */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_RETURN1 */",
        "opmode(0, 0, 0, 0, 1, iABx),       /* OP_FORLOOP */",
        "opmode(0, 0, 0, 0, 1, iABx),       /* OP_FORPREP */",
        "opmode(0, 0, 0, 0, 0, iABx),       /* OP_TFORPREP */",
        "opmode(0, 0, 0, 0, 0, iABC),       /* OP_TFORCALL */",
        "opmode(0, 0, 0, 0, 1, iABx),       /* OP_TFORLOOP */",
        "opmode(0, 0, 1, 0, 0, iABC),       /* OP_SETLIST */",
        -- @TODO: Defer
        "opmode(0, 0, 0, 0, 1, iABx),       /* OP_CLOSURE */",
        "opmode(0, 1, 0, 0, 1, iABC),       /* OP_VARARG */",
        "opmode(0, 0, 1, 0, 1, iABC),       /* OP_VARARGPREP */",
        "opmode(0, 0, 0, 0, 0, iAx),        /* OP_EXTRAARG */",
    },
}

Lua.Group.Unsorted = {
    Tests = { },
    LuaOp = { },
    UnaryOps = { },
    Modes = { },
    Instructions = {
        Codes = { },
        Names = { },
        VM = { },
    },
    TaggedMethods = {
        Opr = {
            "TM_LT,",
            "TM_LE,",
            "TM_CONCAT,",
            "TM_CALL,",
            "TM_CLOSE,",
        },
        Names = {
            "\"__lt\",",
            "\"__le\",",
            "\"__concat\",",
            "\"__call\",",
            "\"__close\",",
        },
    },
    BinaryOps = {
        Opr = {
            "OPR_CONCAT, /* string operator */",
            "OPR_AND, /* logical operator */",
            "OPR_OR, /* logical operator */",
        },
        Priority = {
            "{9, 8}, /* '..' (right associative) */",
            "{2, 2}, /* and */",
            "{1, 1}, /* or */",
        },
    },
    KModes = { },
    KInstructions = { Codes = { }, Names = { }, VM = { } },
}

return Lua
